<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>EC910 - Classical Linear Regression Model</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">EC910</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-lectures" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Lectures</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-lectures">    
        <li>
    <a class="dropdown-item" href="./lecture-1.html">
 <span class="dropdown-text">Lecture 1</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./lecture-2.html">
 <span class="dropdown-text">Lecture 2</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./lecture-3.html">
 <span class="dropdown-text">Lecture 3</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-seminars" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Seminars</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-seminars">    
        <li>
    <a class="dropdown-item" href="./seminar-1.html">
 <span class="dropdown-text">Seminar 1</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-additional" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Additional</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-additional">    
        <li>
    <a class="dropdown-item" href="./material-cef.html">
 <span class="dropdown-text">Conditional Expectation Function</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./material-linearalgebra.html">
 <span class="dropdown-text">Linear Algebra</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview"><span class="header-section-number">1</span> Overview</a></li>
  <li><a href="#model-specification" id="toc-model-specification" class="nav-link" data-scroll-target="#model-specification"><span class="header-section-number">2</span> Model Specification</a>
  <ul class="collapse">
  <li><a href="#intercept" id="toc-intercept" class="nav-link" data-scroll-target="#intercept"><span class="header-section-number">2.1</span> Intercept</a></li>
  <li><a href="#matrix-notation" id="toc-matrix-notation" class="nav-link" data-scroll-target="#matrix-notation"><span class="header-section-number">2.2</span> Matrix notation</a></li>
  </ul></li>
  <li><a href="#clrm-assumptions" id="toc-clrm-assumptions" class="nav-link" data-scroll-target="#clrm-assumptions"><span class="header-section-number">3</span> CLRM Assumptions</a>
  <ul class="collapse">
  <li><a href="#non-random-x" id="toc-non-random-x" class="nav-link" data-scroll-target="#non-random-x"><span class="header-section-number">3.1</span> Non-random <span class="math inline">\(X\)</span></a></li>
  <li><a href="#identification" id="toc-identification" class="nav-link" data-scroll-target="#identification"><span class="header-section-number">3.2</span> Identification</a></li>
  </ul></li>
  <li><a href="#interpretation" id="toc-interpretation" class="nav-link" data-scroll-target="#interpretation"><span class="header-section-number">4</span> Interpretation</a>
  <ul class="collapse">
  <li><a href="#semi-elasticities-and-elasticities" id="toc-semi-elasticities-and-elasticities" class="nav-link" data-scroll-target="#semi-elasticities-and-elasticities"><span class="header-section-number">4.1</span> Semi-elasticities and elasticities</a></li>
  </ul></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references"><span class="header-section-number">5</span> References</a></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="lecture-1.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Classical Linear Regression Model</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="overview" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="overview"><span class="header-section-number">1</span> Overview</h2>
<p>In this handout we will revisit the Classical Linear Regression Model (CLRM) <span class="citation" data-cites="wooldridge2010">(see <a href="#ref-wooldridge2010" role="doc-biblioref">Wooldridge 2010, chaps. 1–2</a>)</span>. The goal of this week’s lecture is to:</p>
<ol type="1">
<li><p>understand the model specification;</p></li>
<li><p>it’s underlying assumptions;</p></li>
<li><p>and the appropriate interpretation (correlation vs causation).</p></li>
</ol>
</section>
<section id="model-specification" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="model-specification"><span class="header-section-number">2</span> Model Specification</h2>
<p>The linear population regression model is given by,</p>
<p><span class="math display">\[
\begin{aligned}
  Y_i =&amp; X_i'\beta+\varepsilon_i \\
  =&amp; \beta_1\mathbf{1}+\beta_2X_{i2}+\beta_3X_{i3}+...+\beta_kX_{ik}+\varepsilon_i
\end{aligned}
\]</span></p>
<p>for <span class="math inline">\(i = 1,2,...,n\)</span>. Where,</p>
<ul>
<li><p><span class="math inline">\(i\)</span>: unit of observation; e.g.&nbsp;individual, firm, union, political party, etc.</p></li>
<li><p><span class="math inline">\(Y_i \in \mathbb{R}\)</span>: scalar random variable.</p></li>
<li><p><span class="math inline">\(X_i \in \mathbb{R}^k\)</span>: <span class="math inline">\(k\)</span>-dimensional (column<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>) vector of regressors.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p></li>
<li><p><span class="math inline">\(\beta\)</span>: <span class="math inline">\(k\)</span>-dimensional, non-random vector of unknown population parameters.</p></li>
<li><p><span class="math inline">\(\varepsilon_i\)</span>: <em>unobserved</em>, random error term.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p></li>
</ul>
<p>The linear population regression equation is <strong>linear in parameters</strong>. This is an important assumption that does NOT restrict the model from being non-linear in regressors. For example, the equation</p>
<p><span class="math display">\[Y_i = \beta_1 + \beta_2X_{i2} + \beta_3X_{i2}^{\color{red}{2}} + \varepsilon_i\]</span> non-linear in <span class="math inline">\(X_{i2}\)</span>, but still linear in parameters. In contrast, the equation</p>
<p><span class="math display">\[Y_i = \beta_1 + \beta_2X_{i2} + ({\color{red}{\beta_2\beta_3}})X_{i3} + \varepsilon_i\]</span> is non-linear in parameters.</p>
<section id="intercept" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="intercept"><span class="header-section-number">2.1</span> Intercept</h3>
<p>The constant (intercept) in the equation serves an important purpose. While there is no <em>a priori</em> reason for the model to have a constant term, it does ensure that the error term is mean zero.</p>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Suppose <span class="math inline">\(E[\varepsilon_i] = \gamma\)</span>.</p>
<p>We can then define a new error term, <span class="math inline">\(\upsilon_i = \varepsilon_i - \gamma\)</span>, such <span class="math inline">\(E[\upsilon_i] = \gamma\)</span>. The population regression model can be rewritten as, <span class="math display">\[ \begin{aligned} Y_i =&amp; X_ i'\beta + v_i + \gamma  \\
=&amp; \underbrace{(\beta_1+\gamma)}_{\tilde{\beta}_1}\mathbf{1} + \beta_2X_{i2} + \beta_3X_{i3} + ... + \beta_kX_{ik} + v_i
\end{aligned}
\]</span> The model has a new intercept <span class="math inline">\(\tilde{\beta}_1=\beta_1 + \gamma\)</span>, but the other parameters remain unchanged.</p>
</div>
</section>
<section id="matrix-notation" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="matrix-notation"><span class="header-section-number">2.2</span> Matrix notation</h3>
<p>For a sample of <span class="math inline">\(n\)</span> observations, we can stack the unit-level linear regression equation into a vector,</p>
<p><span class="math display">\[
Y =\underbrace{\begin{bmatrix}Y_1 \\ Y_2 \\ \vdots \\ Y_n \end{bmatrix}}_{n\times 1} = \underbrace{\begin{bmatrix}X_1'\beta \\ X_2'\beta \\ \vdots \\ X_n'\beta\end{bmatrix}}_{n\times 1}  + \underbrace{\begin{bmatrix}\varepsilon_1 \\ \varepsilon_2 \\ \vdots \\ \varepsilon_n\end{bmatrix}}_{n\times 1}  
= \underbrace{\begin{bmatrix}X_{11} &amp; X_{12} &amp; \dots &amp; X_{1k}\\ X_{21} &amp; X_{22} &amp;&amp; \\ \vdots &amp; &amp; \ddots &amp; \\ X_{n1} &amp; &amp; &amp; X_{nk} \end{bmatrix}}_{n\times k} \underbrace{\begin{bmatrix}\beta_1 \\ \beta_2 \\ \vdots \\ \beta_k\end{bmatrix}}_{k\times 1} + \begin{bmatrix}\varepsilon_1 \\ \varepsilon_2 \\ \vdots \\ \varepsilon_n\end{bmatrix} = X\beta + \varepsilon
\]</span> Notice, in matrix notation, you lose the transpose from <span class="math inline">\(X_i'\beta\)</span>. Apart from the absence of the <span class="math inline">\(i\)</span> subscript, this is a useful way of knowing the dimension of the equation (in my notes). You MUST always write <span class="math inline">\(X\beta\)</span> and not <span class="math inline">\(\beta X\)</span>. For the scalar case, <span class="math inline">\(X_i'\beta = \beta'X_i\)</span>, but for the vector case <span class="math inline">\(\beta X\)</span> is not defined since <span class="math inline">\(\beta\)</span> is <span class="math inline">\(k\times 1\)</span> and <span class="math inline">\(X\)</span> is <span class="math inline">\(n\times k\)</span>.</p>
</section>
</section>
<section id="clrm-assumptions" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="clrm-assumptions"><span class="header-section-number">3</span> CLRM Assumptions</h2>
<p><strong>Assumption CLRM 1.</strong> Population regression equation is linear in parameters: <span class="math display">\[Y = X\beta+\varepsilon\]</span></p>
<p><strong>Assumption CLRM 2.</strong> Conditional mean independence of the error term: <span class="math display">\[E[\varepsilon|X]=0\]</span></p>
<p>Together, CLRM 1. and CLRM 2. imply that</p>
<p><span class="math display">\[ E[Y|X] = X\beta  \]</span> This means that the Conditional Expectation Function is known and linear in parameters.</p>
<p>Conditional mean independence implies - by the Law of Iterated Expectations - mean independence of the error term,</p>
<p><span class="math display">\[E[\varepsilon|X]=0 \Rightarrow E\big[E[\varepsilon|X]\big]=E[\varepsilon]=0\]</span></p>
<p>and uncorrelatedness,</p>
<p><span class="math display">\[E[\varepsilon|X]=0 \Rightarrow E[\varepsilon X]=0\]</span> Note, neither of the above statements hold the other way around. Mean independence does not imply conditional mean independence and uncorrelatedness (zero correlation/covariance) does not imply conditional mean independence.</p>
<p>Uncorrelatedness rules out linear relationships between the regressors and error term while conditional mean independence rules out non-linear relationships too.</p>
<p>In general, distributional independence implies mean independence which then implies uncorrelatedness.</p>
<div id="nte-normality">
<p>In the case joint-normally distributed random variables, uncorrelatedness implies independence. That is, if <span class="math display">\[ \begin{bmatrix}Y_1 \\ Y_2\end{bmatrix}\sim N\bigg(\begin{bmatrix}\mu_1 \\ \mu_2\end{bmatrix},\begin{bmatrix}\sigma_1^2 &amp; \sigma_{12}\\ \sigma_{21} &amp; \sigma_2^2\end{bmatrix}\bigg)\]</span> Then <span class="math inline">\(\sigma_{12}=\sigma_{21}=0 \iff f_1*f_2 = f_{12}\)</span>.</p>
</div>
<p>We will later show that uncorrelatedness is sufficient for consistency of the Ordinary Least Squares estimater, while conditional mean independence is required for unbiasedness of OLS.</p>
<p><strong>Assumption CLRM 3.</strong> Homoskedasticity: <span class="math inline">\(Var(\varepsilon|X) = E[\varepsilon\varepsilon'|X] =  \sigma^2I_n\)</span></p>
<p>CLRM 3. states that the variance of the error term is independent of <span class="math inline">\(X\)</span> and constant across units. The diagonal nature of the covariance matrix also implies that the error terms are uncorrelated across units in the data. Note, this does not imply independence of the error terms across units.</p>
<p>Models with heteroskedasticity relax the assumption of constant variance, allowing for a richer variance-covariance matrix that typically depends on <span class="math inline">\(X\)</span>.</p>
<p>This assumption is unlikely to hold in time-series models where units represent repeated observations across time. Such violations are referred to as serial correlation or autocorrelation.</p>
<p>Even in cross-sectional data settings, you can have non-zero correlations across units in the data. A common instance of this is the case of clustering. Clustering can occur when units experience common/correlated ‘shocks’; for example, the data contains groups of students from the same classroom who have a the same teacher. This can also be the result of clustered sampling, a common practice in multi-stage survey design.</p>
<p><strong>Assumption CLRM 4.</strong> Full rank: <span class="math inline">\(rank(X)=k\)</span><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<p>CLRM 4. is some time referred to as the absence of perfect (or exact) collinearity. Do not confuse this with multicollinearity. Multicollinearity occurs when regressors are highly (linearly) correlated with one another, yielding imprecise estimates.</p>
<p><strong>Assumption CLRM 5.</strong> Normality of the error term: <span class="math inline">\(U|X \sim N(0,\sigma^2 I_n)\)</span></p>
<p><strong>Assumption CLRM 6.</strong> Observations <span class="math inline">\(\{(Y_i,X_i): i=1,...,n\}\)</span> are independently and identically distributed (iid).</p>
<p>CLRM 5 &amp; 6 are not part of the Classical assumptions, but do simplify the problem of inference. Note, CLRM 5 implies independence across error terms, not implied by CLRM 4.</p>
<section id="non-random-x" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="non-random-x"><span class="header-section-number">3.1</span> Non-random <span class="math inline">\(X\)</span></h3>
<p>There is an alternative version of the CLRM in which <span class="math inline">\(X\)</span> is a non-random, matrix of regressors/predictors. With <span class="math inline">\(X\)</span> fixed, the error term is the only only random variable in the model. CLRM assumptions 1 and 4 remain the same, while CLRM 2, 3, 5, and 6 become:</p>
<p><strong>Assumption CLRM 2<sup>a</sup>.</strong> Mean independence of the error term: <span class="math display">\[E[\varepsilon]=0\]</span></p>
<p><strong>Assumption CLRM 3<sup>a</sup>.</strong> Homoskedasticity: <span class="math inline">\(Var(\varepsilon) = \sigma^2I_n\)</span></p>
<p><strong>Assumption CLRM 5<sup>a</sup>.</strong> Normality of the error term: <span class="math inline">\(\varepsilon \sim N(0,\sigma^2 I_n)\)</span></p>
<p><strong>Assumption CLRM 6<sup>a</sup>.</strong> Observations <span class="math inline">\(\{\varepsilon_i: i=1,...,n\}\)</span> are independently and identically distributed (iid).</p>
</section>
<section id="identification" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="identification"><span class="header-section-number">3.2</span> Identification</h3>
<p>CLRM 1,2 and 4. are the <em>identifying</em> assumptions of the model. These assumptions allow us to write the parameter of interest as a set of ‘observable’ moments in the data. We can demonstrate this as follows.</p>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Start with CLRM 2.</p>
<p><span class="math display">\[
    E[\varepsilon_i|X_i]=0
\]</span></p>
<p>Pre-multiply by the vector <span class="math inline">\(X_i\)</span>, <span class="math display">\[
        X_iE[\varepsilon_i|X_i]=0
\]</span> Since the expectation is conditional on <span class="math inline">\(X_i\)</span>, we can bring <span class="math inline">\(X_i\)</span> inside the expectation function,</p>
<p><span class="math display">\[
        E[X_i\varepsilon_i|X_i]=0
    \]</span> This conditional expectation is a random-function of <span class="math inline">\(X_i\)</span>. If we take the expectation of this function w.r.t. <span class="math inline">\(X\)</span>, we achieve the aforementioned result that conditional mean independence implies zero covariance, <span class="math display">\[
        E\left[E[X_i\varepsilon_i|X_i]\right]=E[X_i\varepsilon_i]=0
    \]</span></p>
<p>Now substitute in for <span class="math inline">\(\varepsilon_i\)</span> using the linear regression model from CLRM 1 and separate the resulting two terms,</p>
<p><span class="math display">\[
\begin{aligned}
    &amp;E[X_i(Y_i-X_i'\beta)]=0 \\
    \Rightarrow &amp;E[X_iX_i']\beta=E[X_iY_i]
\end{aligned}
\]</span></p>
<p>Since <span class="math inline">\(\beta\)</span> is a non-random vector, we can remove it from the expectation function.</p>
<p>Now we have a system of linear equations (of the form <span class="math inline">\(Av = b\)</span>) with a unique solution if and only if the matrix <span class="math inline">\(E[X_iX_i']\)</span> is invertible. For the inverse of <span class="math inline">\(E[X_iX_i']\)</span> to exist, we require CLRM 3.</p>
<p><span class="math display">\[
    \beta = E[X_iX_i']^{-1}E[X_iY_i]
\]</span></p>
</div>
<p>We cannot compute <span class="math inline">\(\beta\)</span> because we do not know the joint distribution of <span class="math inline">\((Y_i,X_i)\)</span> needed to solve for the variance-covariance matrices. However, <span class="math inline">\(\beta\)</span> is (point) identified because both <span class="math inline">\(Y\)</span> and <span class="math inline">\(X\)</span> are observed in the data and the parameters are “pinned down” by a unique set of ‘observable’ moments in the data.</p>
<p><span class="math inline">\(\beta\)</span> is not identified if the above system of linear equations does not have a unique solution. This will occur if two or more of the regressors are perfectly colinear.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> <span class="math inline">\(\beta\)</span> is also not be identified is the resulting expression for <span class="math inline">\(\beta\)</span> includes ‘objects’ (moments, distribution/scale parameters) that are not ‘observed’ in the data. For example, if the error is not mean independent, the above expression will include a bias term that depends on <span class="math inline">\(E[X_i'\varepsilon_i]\)</span>.</p>
<p>In this instance, the identification of <span class="math inline">\(\beta\)</span> is scale dependent. That is, if we multiply <span class="math inline">\(Y_i\)</span> by a scalar, <span class="math inline">\(\beta\)</span> is multiplied by the same scalar. Consider cases where a researcher is modelling standardized test-scores.</p>
</section>
</section>
<section id="interpretation" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="interpretation"><span class="header-section-number">4</span> Interpretation</h2>
<p>In this linear regression model each slope coefficient has a partial derivative interpretation,</p>
<p><span class="math display">\[
\beta_j = \frac{\partial E[Y_i|X_i]}{\partial X_{ij}}
\]</span> or, as a vector, <span class="math display">\[
\beta = \frac{\partial E[Y_i|X_i]}{\partial X_{i}} = \begin{bmatrix}\frac{\partial E[Y_i|X_i]}{\partial X_{i1}}\\ \vdots \\ \frac{\partial E[Y_i|X_i]}{\partial X_{ik}}\end{bmatrix} = \begin{bmatrix}\beta_1\\ \vdots \\ \beta_k\end{bmatrix}
\]</span></p>
<p>Note, the derivative is expressed in terms of changes in the <em>expected</em> value of <span class="math inline">\(Y_i\)</span> (conditional on <span class="math inline">\(X_i\)</span>), not <span class="math inline">\(Y_i\)</span> itself. This is because <span class="math inline">\(Y_i\)</span> is a random variable, but under CLRM 1 &amp; 2</p>
<p><span class="math display">\[
E[Y_i|X_i] = X_i'\beta
\]</span></p>
<p>For a given value of <span class="math inline">\(X_i\)</span>, the above expression is non-random.</p>
<p>As <span class="math inline">\(\beta_j\)</span> is a partial derivative, its interpretation is one that “holds fixed” the value of other regressors (i.e.&nbsp;<em>ceteris paribus</em>). Because of this, many researchers apply the experimental language of control variables when interpretting regression coefficients.</p>
<p>Consider this simplified version of the linear regression model popularized by Mincer.</p>
<p><span class="math display">\[WAGE_i = \gamma_1 + \gamma_2EDU_i + \gamma_3EXP_ i + \upsilon_i\]</span> where,</p>
<ul>
<li><p><span class="math inline">\(WAGE_i\)</span>: individual wage (£’s)</p></li>
<li><p><span class="math inline">\(EDU_i\)</span>: years of schooling/education</p></li>
<li><p><span class="math inline">\(EXP_i\)</span>: years of experience</p></li>
</ul>
<p>Assuming <span class="math inline">\(E[\upsilon_i|S_i,EXP_i]=0\)</span>, <span class="math inline">\(\beta_3\)</span> is the expected change in wages from an additional year of experience, holding fixed years of schooling. The model implies that if we were to consider two individuals with the same years of schooling, but a 1-year difference in work experience, then we would expect the more experienced worker to earn <span class="math inline">\(\beta_3\)</span> £’s more.</p>
<p>We would get the same interpretation from an experiment where we <em>control</em> individual schooling, but (randomly) vary years of experience by one year across units in the population.</p>
<p>Remember, for the above linear regression model, this interpretation is based on the assumption that the conditional expectation function is correctly specified. If no, then this interpretation is incorrect. Moreover, there are other ways to think about “controlling” for covariates that we will address towards the end of this module.</p>
<section id="semi-elasticities-and-elasticities" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="semi-elasticities-and-elasticities"><span class="header-section-number">4.1</span> Semi-elasticities and elasticities</h3>
<p>The original Mincer equation has the outcome as the log of wages,</p>
<p><span class="math display">\[\ln(WAGE_i) = \gamma_1 + \gamma_2EDU_i + \gamma_3EXP_ i + \gamma_4EXP^2_ i + \upsilon_i\]</span> The interpretation of <span class="math inline">\(\beta_3\)</span> is now in terms of expected log-points of wages.</p>
<p><span class="math display">\[
\beta_3 = \frac{\partial E[ln(WAGE_i)|EDU_i,EXP_i]}{\partial EXP_{i}}
\]</span></p>
<p>This can be converted into a percentage change in (expected) wages,</p>
<p><span class="math display">\[\%\Delta E[WAGE_i|EDU_i,EXP_i] = (\exp^{\beta_3}-1)\times 100\]</span> For values of <span class="math inline">\(\beta_3 \in [-0.1,0.1]\)</span> this value is closely approximated by <span class="math inline">\(\beta_3\times 100\)</span>.</p>
<p>Next, consider a model where the regressor is in logs, while the outcome remains in levels. For example, a model of commuting cost as a function of distance to work,</p>
<p><span class="math display">\[COST_i = \gamma_1 + \gamma_2\ln(DIST_i) + + \nu_i\]</span> Here the interpretation of <span class="math inline">\(\beta_2\)</span> is, <span class="math display">\[
\beta_2 = \frac{\partial E[COST_i|\ln(DIST_i)]}{\partial \ln(DIST_i)}
\]</span> We can convert this to <span class="math inline">\(\%\Delta\)</span> in <span class="math inline">\(DIST_i\)</span>, using the fact that a 1% change in distance implies a change in log points of <span class="math inline">\(\ln(1.01)\approxeq 0.01\)</span>. Thus, we can approximate the expected change in cost by <span class="math inline">\(\beta_2/100\)</span>.</p>
<p>Finally, when both the outcome and regressor are logged, the coefficient as an elasticity interpretation. For example, in the taxation literature, it is common to see taxable income modeled as a function of the (marginal) tax rate,</p>
<p><span class="math display">\[
  \ln(INC_i) = \beta_1 + \beta_2 \ln(RATE_i) + \xi_i
\]</span> Here, <span class="math inline">\(\beta_2\)</span> has an tax elasticity interpretation,</p>
<p><span class="math display">\[
  \beta_2 = \frac{\partial E[\ln(INC_i)|\ln(RATE_i)]}{\partial \ln(RATE_i)} = \frac{\%\Delta E[INC_i|RATE_i]}{\%\Delta RATE_i}
\]</span></p>
</section>
</section>
<section id="references" class="level2" data-number="5">




</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">5 References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-wooldridge2010" class="csl-entry" role="listitem">
Wooldridge, Jeffrey M. 2010. <em>Econometric Analysis of Cross Section and Panel Data</em>. MIT press.
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>My notation assumes that <span class="math inline">\(X_i\)</span> is a column vector, which makes <span class="math inline">\(X_i'\beta\)</span> a scalar. Wooldridge (2010) uses the notation <span class="math inline">\(X_i\beta\)</span>, implying that <span class="math inline">\(X_i\)</span> is a row vector. This is a matter of preference.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>You might also refer to the vector of regressors as covariates or explanatory variables. Some texts will use the term independent variables, but this name implies a specific relationship between <span class="math inline">\(Y\)</span> and <span class="math inline">\(X\)</span> that need not hold.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>This is <strong>NOT</strong> the residual.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>See extra material on Linear Algebra. Since <span class="math inline">\(X\)</span> is a random variable we should add to the assumption: <span class="math inline">\(rank(X) = k\)</span> <em>almost surely</em> (abbreviated a.s.). This means that the set of events in which <span class="math inline">\(X\)</span> is not full rank occur with probability 0. The reason for this addition is that such a set of events may not be empty.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>There are many such failures of (parametric) identification in models that include dummy variables (or fixed effects). Earlier we saw that the intercept is not separately identified from the mean of the error term. Mean independence of the error term, <span class="math inline">\(E[\varepsilon_i]=0\)</span>, is required for us to separately ‘identify’ <span class="math inline">\(\beta_1\)</span>.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>